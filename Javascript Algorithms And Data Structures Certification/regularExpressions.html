<!DOCTYPE html>
<html>
<head>
	<title>Basic Javascript</title>
</head>
<body>
	<script type="text/javascript">
		//Testing regular expressions
		//
		let myString = "Hello, World!";
		let myRegex = /Hello/;
		let result = myRegex.test(myString);

		console.log("Result: ", result);

		//Testing regular expressions with alternatives
		//
		let petString = "James has a pet cat.";
		let petRegex = /dog|cat|bird|fish/;
		let resultPattern = petRegex.test(petString); 

		console.log("Result:", resultPattern);


		//Ignore the case of the characters while matching
		//
		let egString = "freeCodeCamp";
		let fccRegex = /freecodecamp/i; 
		let resultI = fccRegex.test(egString);

		console.log("Result:", resultI);

		//Extract matching string
		//
		let extractStr = "Extract the word 'coding' from this string.";
		let codingRegex = /coding/; 
		let resultM = extractStr.match(codingRegex); // Syntax is opposite to .test()
		console.log("Result: ", resultM);

		//Extract repeating instances of a match
		//
		let twinkleStar = "Twinkle, twinkle, little star";
		let starRegex = /Twinkle/gi; 
		let resultR = twinkleStar.match(starRegex); 

		console.log("Result: ", resultR);

		//Wild character matching
		//
		let exampleStr = "Let's have fun with regular expressions!";
		let unRegex = /.un/;
		let resultW = unRegex.test(exampleStr);
		let resultWM = exampleStr.match(unRegex);

		console.log("Result: ", resultW, resultWM);

		//Specific character matching
		//
		let quoteSample = "Beware of bugs in the above code; I have only proved it correct, not tried it.";
		let vowelRegex = /[aeiou]/gi; 
		let resultV = quoteSample.match(vowelRegex); 

		console.log("Result: ", resultV);

		//Another Example for character matching
		//
		let bigStr = "big";
		let bagStr = "bag";
		let bugStr = "bug";
		let bogStr = "bog";
		let bgRegex = /b[aiu]g/;
		bigStr.match(bgRegex); // Returns ["big"]
		bagStr.match(bgRegex); // Returns ["bag"]
		bugStr.match(bgRegex); // Returns ["bug"]
		bogStr.match(bgRegex); // Returns null

		//Character set matching
		//
		let quoteSampleA = "The quick brown fox jumps over the lazy dog.";
		let alphabetRegex = /[a-z]/gi; 
		let resultCS = quoteSampleA.match(alphabetRegex);

		console.log("Result: ", resultCS);

		//Match characters and numbers
		//
		let quoteSampleB = "Blueberry 3.141592653s are delicious.";
		let myCNRegex = /[h-s2-6]/gi; 
		let resultCN = quoteSample.match(myCNRegex);

		console.log("Result: ", resultCN);

		//Negated Characters - Characters that do not match
		//
		let quoteSampleN = "3 blind mice.";
		let myRegexN = /[^aeiou0-9]/gi; 
		let resultNC = quoteSampleN.match(myRegexN);

		console.log("Result: ", resultNC);

		//Find recurring matches
		//
		let difficultSpelling = "Mississippi";
		let myRegexRR = /s+/g; 
		let resultRR = difficultSpelling.match(myRegexRR);
		console.log("Result: ", resultRR);

		/*You can use the + character to check if that is the case. Remember, the character or pattern has to be present consecutively. That is, the character has to repeat one after the other.

		For example, /a+/g would find one match in "abc" and return ["a"]. Because of the +, it would also find a single match in "aabc" and return ["aa"].

		If it were instead checking the string "abab", it would find two matches and return ["a", "a"] because the a characters are not in a row - there is a b between them. */

		//Matching 0 or more characters
		//
		let soccerWord = "gooooooooal!";
		let gPhrase = "gut feeling";
		let oPhrase = "over the moon";
		let goRegex = /go*/;
		soccerWord.match(goRegex); // Returns ["goooooooo"]
		gPhrase.match(goRegex); // Returns ["g"]
		oPhrase.match(goRegex); // Returns null

		//Lazy and greedy matching
		//
		let text = "<h1>Winter is coming</h1>";
		let myRegexL = /<.[1]*?>/; //Such that only h1 should be matched
		let resultL = text.match(myRegexL);

		console.log("Result: ", resultL);

		/*
		In regular expressions, a greedy match finds the longest possible part of a string that fits the regex pattern and returns it as a match. The alternative is called a lazy match, which finds the smallest possible part of the string that satisfies the regex pattern.

		You can apply the regex /t[a-z]*i/ to the string "titanic". This regex is basically a pattern that starts with t, ends with i, and has some letters in between.

		Regular expressions are by default greedy, so the match would return ["titani"]. It finds the largest sub-string possible to fit the pattern.

		However, you can use the ? character to change it to lazy matching. "titanic" matched against the adjusted regex of /t[a-z]*?i/ returns ["ti"].
		*/
	
		//Match the string when it appears first in the line
		//
		let rickyAndCal = "Cal and Ricky both like racing and Cal likes dancing too.";
		let calRegex = /^Cal/; 
		let resultF = calRegex.test(rickyAndCal);

		console.log("Result: ", resultF);

		//Matching at the end
		//
		let theEnding = "This is a never ending story";
		let storyRegex = /story$/;
		storyRegex.test(theEnding);
		// Returns true
		let noEnding = "Sometimes a story will have to end";
		storyRegex.test(noEnding);
		// Returns false
		// 
		
		//Shorthand for all alphanumberic characters
		//
		let quoteSampleAN = "The five boxing wizards jump quickly.";
		let alphabetRegexV2 = /\w/gi; 
		let resultAN = quoteSampleAN.match(alphabetRegexV2).length; 
		
		//Checking username validity
		//
		let username = "JackOfAllTrades";
		let userCheck = /^[a-z]{2,}\d*$/i; //{2,} indicates minimum 2 characters
		//\d indicates only numbers 
		//Alternative /^[a-z]{2,}\w*/i
		let resultU = userCheck.test(username);

		//Matching white space
		//
		let sample = "Whitespace is important in separating words";
		let countWhiteSpace = /\s+/g; //\S is everything EXCEPT white space
		let resultWS = sample.match(countWhiteSpace);

		//Check for optional character
		//
		let american = "color";
		let british = "colour";
		let rainbowRegex= /colou?r/;
		rainbowRegex.test(american); // Returns true
		rainbowRegex.test(british); // Returns true

		//Use lookaheads in the pwRegex to match passwords that are greater than 5 characters long and have two consecutive digits.
		//
		let sampleWord = "astronaut";
		let pwRegex = /(?=\w{5,})(?=\D*\d{2})/; 
		let resultP = pwRegex.test(sampleWord);

		//Use capture groups in reRegex to match numbers that are repeated only three times in a string, each separated by a space.
		//
		let repeatNum = "42 42 42";
		let reRegex = /^(\d+)\s\1\s\1$/; 
		let resultNum = reRegex.test(repeatNum);

		//You can search and replace text in a string using .replace() on a string. The inputs for .replace() is first the regex pattern you want to search for. The second parameter is the string to replace the match or a function to do something.
		//
		let wrongText = "The sky is silver.";
		let silverRegex = /silver/;
		wrongText.replace(silverRegex, "blue");
		// Returns "The sky is blue."

		// Another Example
		// 
		"Code Camp".replace(/(\w+)\s(\w+)/, '$2 $1');
		// Returns "Camp Code"

		//Write a regex and use the appropriate string methods to remove whitespace at the beginning and end of strings.
		//
		let hello = "   Hello, World!  ";
		let wsRegex = /^\s+|\s+$/g;; 
		let resultWSBE = hello.replace(wsRegex, ''); 

	</script>
</body>
</html>